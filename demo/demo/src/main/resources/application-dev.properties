spring.application.name=demo
#server.port=9091

#MySQL 설정
#spring.datasource.url=jdbc:mysql://localhost:3306/jsptest
#spring.datasource.username=jspid
#spring.datasource.password=jsppass

# Docker에 올린 DB 설정
spring.datasource.url=jdbc:mysql://localhost:3305/sunghun_api_shop
spring.datasource.username=sunghun.kim
spring.datasource.password=tjdgns12#
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# create - DB 생성하고 어플리케이션 실행될때 데이터베이스 생성하고 진행하겠다.
## JPA 설정
  # create : SessionFactory가 올라갈 때 테이블을 지우고 새로 만듬. (sql문을 별도로 만들어서 데이터를 넣는 용도로도 사용가능하다.)
  # create-drop : create와 동일하지만, SessionFactory가 내려가면 해당 테이블을 drop시킨다.
  # update : SessionFactory가 올라갈 때 Object를 검사하여 테이블을 alter 시킨다. 데이터는 유지됨.
  # validate : update처럼 Object를 검사하지만, 스키마는 아무것도 건드리지 않고, Object와 스키마의 정보가 다르다면 에러를 발생시킨다.
  # none : 사용하지 않음
spring.jpa.hibernate.ddl-auto=update
# 요청을 받았을때 repository가 동작하는데 우리 동작과 매핑되어 있는 SQL들을 보여줄거냐?(test시 좋음)
spring.jpa.show-sql=true

# 쿼리문을 format해 콘솔에서 가독성좋게 보여주는 설정
spring.jpa.properties.hibernate.format_sql=true

# JPA가 어떻게 쿼리를 만들어서 테이블을 생성하는지 확인하려면 로그 설정을 추가
logging.level.org.hibernate.SQL=debug

#Custom property
sunghun.api.short.uri.id=OK50KchcdDwittZl2dQz
sunghun.api.short.uri.secret=oN8EnapOdp
sunghun.api.loading.message="dev 환경으로 실행되었습니다."